{"version":3,"file":"styled.min.js","sources":["../src/utils.ts","../src/styled.ts"],"sourcesContent":["import stringHash from \"string-hash\";\nimport { splitComma } from \"@daybrush/utils\";\nimport { InjectOptions } from \"./types\";\n\nexport function getHash(str: string) {\n    return stringHash(str).toString(36);\n}\n\nexport function getShadowRoot(parentElement: HTMLElement | SVGElement) {\n    if (parentElement && parentElement.getRootNode) {\n        const rootNode = parentElement.getRootNode();\n\n        if (rootNode.nodeType === 11) {\n            return rootNode;\n        }\n    }\n    return;\n}\n\nexport function replaceStyle(className: string, css: string, options: Partial<InjectOptions>) {\n    if (options.original) {\n        return css;\n    }\n    return css.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, (_, selector) => {\n        const trimmedSelector = selector.trim();\n        return (trimmedSelector ? splitComma(trimmedSelector) : [\"\"]).map(subSelector => {\n            const trimmedSubSelector = subSelector.trim();\n            if (trimmedSubSelector.indexOf(\"@\") === 0) {\n                return trimmedSubSelector;\n            } else if (trimmedSubSelector.indexOf(\":global\") > -1) {\n                return trimmedSubSelector.replace(/\\:global/g, \"\");\n            } else if (trimmedSubSelector.indexOf(\":host\") > -1) {\n                return `${trimmedSubSelector.replace(/\\:host/g, `.${className}`)}`;\n            } else if (trimmedSubSelector) {\n                return `.${className} ${trimmedSubSelector}`;\n            } else {\n                return `.${className}`;\n            }\n        }).join(\", \") + \" {\";\n    });\n}\n\nexport function injectStyle(className: string, css: string, options: Partial<InjectOptions>, shadowRoot: Node, iframeSelector: string) {\n    const iframe = iframeSelector ? document.querySelector(iframeSelector) as HTMLIFrameElement : null;\n    const contentDocument = iframe ? iframe.contentDocument : document;\n    console.log(contentDocument);\n    const style = contentDocument.createElement(\"style\");\n\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-styled-id\", className);\n\n    if (options.nonce) {\n        style.setAttribute(\"nonce\", options.nonce);\n    }\n    style.innerHTML = replaceStyle(className, css, options);\n\n    (shadowRoot || contentDocument.head || contentDocument.body).appendChild(style);\n    return style;\n}\n","import { getHash, injectStyle, getShadowRoot } from \"./utils\";\nimport { StyledInjector, InjectOptions } from \"./types\";\n\n/**\n * Create an styled object that can be defined and inserted into the css.\n * @param - css styles\n */\nfunction styled(css: string, iframeSelector): StyledInjector {\n    const injectClassName = \"rCS\" + getHash(css);\n    let injectCount = 0;\n    let injectElement!: HTMLStyleElement;\n\n    return {\n        className: injectClassName,\n        inject(el: HTMLElement | SVGElement, options: Partial<InjectOptions> = {}) {\n            const shadowRoot = getShadowRoot(el);\n            const firstMount = injectCount === 0;\n            let styleElement: HTMLStyleElement;\n\n            if (shadowRoot || firstMount) {\n                styleElement = injectStyle(injectClassName, css, options, shadowRoot, iframeSelector);\n            }\n            if (firstMount) {\n                injectElement = styleElement;\n            }\n            if (!shadowRoot) {\n                ++injectCount;\n            }\n            return {\n                destroy() {\n                    if (shadowRoot) {\n                        el.removeChild(styleElement);\n                        styleElement = null;\n                    } else {\n                        if (injectCount > 0) {\n                            --injectCount;\n                        }\n                        if (injectCount === 0 && injectElement) {\n                            injectElement.parentNode!.removeChild(injectElement);\n                            injectElement = null;\n                        }\n                    }\n                },\n            };\n        },\n    };\n}\n\nexport * from \"./types\";\nexport default styled;\n"],"names":["injectStyle","className","css","options","shadowRoot","iframeSelector","iframe","document","querySelector","contentDocument","console","log","style","createElement","setAttribute","nonce","innerHTML","original","replace","_","selector","trimmedSelector","trim","splitComma","map","subSelector","trimmedSubSelector","indexOf","join","head","body","appendChild","injectElement","injectClassName","stringHash","toString","injectCount","inject","el","styleElement","parentElement","getRootNode","rootNode","nodeType","getShadowRoot","firstMount","destroy","removeChild","parentNode"],"mappings":";;;;;;;;y7BA0CgBA,EAAYC,EAAmBC,EAAaC,EAAiCC,EAAkBC,OACrGC,EAASD,EAAiBE,SAASC,cAAcH,GAAuC,KACxFI,EAAkBH,EAASA,EAAOG,gBAAkBF,SAC1DG,QAAQC,IAAIF,OA1BaR,EAAmBC,EA2BtCU,EAAQH,EAAgBI,cAAc,gBAE5CD,EAAME,aAAa,OAAQ,YAC3BF,EAAME,aAAa,iBAAkBb,GAEjCE,EAAQY,OACRH,EAAME,aAAa,QAASX,EAAQY,OAExCH,EAAMI,WAnCmBf,EAmCMA,EAnCaC,EAmCFA,EAAKC,EAlCnCc,SACDf,EAEJA,EAAIgB,QAAQ,6BAA8B,SAACC,EAAGC,OAC3CC,EAAkBD,EAASE,cACzBD,EAAkBE,EAAWF,GAAmB,CAAC,KAAKG,IAAI,SAAAC,OACxDC,EAAqBD,EAAYH,cACC,IAApCI,EAAmBC,QAAQ,KACpBD,GACyC,EAAzCA,EAAmBC,QAAQ,WAC3BD,EAAmBR,QAAQ,YAAa,KACD,EAAvCQ,EAAmBC,QAAQ,SAC3B,GAAGD,EAAmBR,QAAQ,UAAW,IAAIjB,GAC7CyB,EACA,IAAIzB,MAAayB,EAEjB,IAAIzB,IAEhB2B,KAAK,MAAQ,SAkBnBxB,GAAcK,EAAgBoB,MAAQpB,EAAgBqB,MAAMC,YAAYnB,GAClEA,SClDX,SAAgBV,EAAaG,OAGrB2B,EAFEC,EAAkB,MDHjBC,ECGiChC,GDHjBiC,SAAS,ICI5BC,EAAc,QAGX,CACHnC,UAAWgC,EACXI,OAAA,SAAOC,EAA8BnC,gBAAAA,UAG7BoC,EAFEnC,WDPYoC,MACtBA,GAAiBA,EAAcC,YAAa,KACtCC,EAAWF,EAAcC,iBAEL,KAAtBC,EAASC,gBACFD,GCEYE,CAAcN,GAC3BO,EAA6B,IAAhBT,SAGfhC,GAAcyC,KACdN,EAAevC,EAAYiC,EAAiB/B,EAAKC,EAASC,EAAYC,IAEtEwC,IACAb,EAAgBO,GAEfnC,KACCgC,EAEC,CACHU,QAAA,WACQ1C,GACAkC,EAAGS,YAAYR,GACfA,EAAe,OAEG,EAAdH,KACEA,EAEc,IAAhBA,GAAqBJ,IACrBA,EAAcgB,WAAYD,YAAYf,GACtCA,EAAgB"}